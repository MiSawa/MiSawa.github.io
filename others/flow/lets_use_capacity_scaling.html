<!doctype html>
<html>
  <head>
    <meta charset="utf-8">

    <!-- Always force latest IE rendering engine or request Chrome Frame -->
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">

    <!-- Use title if it's in the page YAML frontmatter -->
    <title>容量スケーリング法のすゝめ - みさわめも</title>

    <link href="../../stylesheets/normalize.css" rel="stylesheet" /><link href="../../stylesheets/all.css" rel="stylesheet" /><link href="../../stylesheets/rouge.css" rel="stylesheet" />
    <script src="../../javascripts/base.js"></script>
      <script type="text/javascript" src="https://s.hatena.ne.jp/js/HatenaStar.js"></script>
<script type="text/javascript">
Hatena.Star.Token = 'bd3a38c3b5f80b3ffb7ac27a6d10b8a144d8a948';
Hatena.Star.SiteConfig = {
  entryNodes: {
    'div#main' : {
      uri: 'document.location',
      title: 'document.title',
      container: 'span.hatena_star'
    }
  }
};
</script>

      <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

      <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
 (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
 m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
 })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-25117970-3', 'misawa.github.io');
ga('require', 'linkid', 'linkid.js');
ga('require', 'displayfeatures');
ga('send', 'pageview');
      </script>
  </head>

  <body class='others others_flow others_flow_lets_use_capacity_scaling'>
  <div id='menu'>
    <ul>
      <li> <a href="../../index.html">top</a> </li>
      <li> <a href="../../atcoder/index.html">atcoder</a> </li>
      <li> <a href="../../topcoder/index.html">topcoder</a> </li>
      <li> <a href="../../yukicoder/index.html">yukicoder</a> </li>
      <li> <a href="../../aoj/index.html">aoj</a> </li>
      <li> <a href="../../tags/index.html">tags</a> </li>
      <li> <a href="../index.html">others</a> </li>
    </ul>
  </div>

  <div id='main'>
    <span class="social_button_box">
        <span class="social_button" style="">
          <span class="hatena_star"></span>

        </span>
        <span class="social_button" style="">
          <a href="https://twitter.com/share" class="twitter-share-button" data-via="Mi_Sawa" data-dnt="true">Tweet</a>

        </span>
    </span>

        <div style="display:none">`$$
\newcommand{\vec}[1]{\mathbf{#1}}
\def\vecb{\vec{b}}
\def\vecf{\vec{f}}
\def\vecp{\vec{p}}
\def\veczero{\vec{0}}
\def\U{\mathcal{U}}
\newcommand{\floor}[1]{\lfloor #1 \rfloor}
$$`</div>

<h1>容量スケーリング法のすゝめ</h1>

<h2>要約</h2>

<ul>
<li>最小費用流問題に対する最短路反復法(Successive Shortest Path, SSP)や Primal-Dual 法<sup id="fnref1"><a href="#fn1">1</a></sup>と呼ばれるアルゴリズムは, 少し弄ると弱多項式時間アルゴリズムにできる.</li>
<li>具体的には, $O(\U \cdot \mathrm{SP_+}(n, m, nC)$ が $O(m \log \U \cdot \mathrm{SP_+}(n, m, nC))$ になる.</li>
<li>$\mathrm{SP_+}(n, m, nC)$ は$n$ 頂点 $m$ 辺, 費用高々 $nC$ のグラフの一点から全点への最短路問題を解くのにかかる時間. 以下では実装をサボったダイクストラ法なので $O(m \log m)$, $\exists k: m = O(n^k)$ を仮定すると合計 $O(m^2 \log \U \log n)$.</li>
</ul>

<h2>まえがき</h2>

<p><a href="library_design.html">ぼくの考えたさいきょうのフローライブラリ</a> では, その速さは特に追求せず, SSP を用いたライブラリの設計例を紹介した.
この記事では, 前回完成したライブラリを少し変更することで, 計算量を改善する.</p>

<p>書いた後に参考文献を漁っていたら, <em>この形の実装だと多項式時間な計算量が証明されていない</em> とか書いてあったので, 間違っていたらごめんなさい.</p>

<p>この形で多項式時間を示している文献を知っている方, もしくは間違えているところを見つけ方は, そっと報告してくれると喜びます.
正しいことが (僕以外の人の手によって) 知られている前処理方法についても, 最後に言及します.</p>

<h2>背景知識</h2>

<p>この章は読み飛ばしても差し支えない. 計算量解析で必要なものの準備を兼ねて, LP と容量スケーリング法のかかわりと, 容量スケーリング法の invariant を見る.</p>

<h3>LP と Primal-Dual 法</h3>

<p>最小費用流問題<sup id="fnref2"><a href="#fn2">2</a></sup>は, その線型計画問題としての表現と強双対性を使うと, 次のような問題と捉えられる;</p>

<p>与えられた有向グラフ $G = (E, V)$ と $\vec{b} = \{b_v\}_{v \in V}$, $\vec{l} = \{l_e\}_{e \in E}$, $\vec{u} = \{u_e\}_{e \in E}$, $\vec{c} = \{c_e\}_{e \in E}$ に対し,
$\vec{f} = \{f_e\}_{e \in E}$, $\vec{p} = \{p_v\}_{v \in V}$ で, 次を満たすものを求めよ.</p>

<ul>
<li>$l_e \leq f_e \leq u_e, \quad \forall e \in E$ (容量制約)</li>
<li>$\sum_{e \in \delta^+(v)} f_e - \sum_{e \in \delta^-(v)} f_e = b_v, \quad \forall v \in V$ (フロー整合性条件)</li>
<li>$f_e > l_e \Rightarrow c_e + p_u - p_v \leq 0, \quad \forall e = (u, v) \in E$ (相補性条件)</li>
<li>$f_e < u_e \Rightarrow c_e + p_u - p_v \geq 0, \quad \forall e = (u, v) \in E$ (相補性条件)</li>
</ul>

<p>このフロー整合性条件は, 主問題が infeasible であった時のことを考慮し, 残余グラフ $G_\vecf$ と余剰量 $e_\vecf(v) := b_v - (\sum_{e \in \delta^+(v)} f_e - \sum_{e \in \delta^-(v)} f_e)$ を用いて次のように書き直しておく.</p>

<ul>
<li>$G_\vecf$ 上に $e_\vecf(v) > 0$ な頂点から $e_\vecf(v) < 0$ な頂点へのパス(残余パス)が存在しない. (カット条件<sup id="fnref3"><a href="#fn3">3</a></sup>)</li>
</ul>

<p>Primal-Dual 法は, 容量制約と相補性条件を満たす主双対ペア $(\vec{f}, \vec{p})$ を持ち, カット条件が満たされるまで解を改善するアルゴリズムである.
具体的には, 初期解を得た後, 次の2つのステップを交互に繰り返すアルゴリズムである.</p>

<ul>
<li>$\vec{f}$ は固定しておき, 相補性条件を保ちつつ $\vec{p}$ を変更することで, 双対目的関数値を改善する.</li>
<li>$\vec{p}$ は固定しておき, 相補性条件を保ちつつ $\vec{f}$ を変更することで, フローをより整合させる. すなわち $G_\vecf$ 上での $e_\vecf(v) > 0$ な頂点全体から $e_\vecf(v) < 0$ な頂点全体へのカット容量を小さくする.</li>
</ul>

<h3>相補性条件の緩和</h3>

<p>Primal-Dual 法は相補性条件を常に保っていた. 容量スケーリング法では, 一部を $\Delta$-緩和した, 次の条件を考える.</p>

<ul>
<li>$l_e \leq f_e \leq u_e, \quad \forall e \in E$ (容量制約)</li>
<li>$G^\Delta_\vecf$ 上に $e_\vecf(v) \ge +\Delta$ な頂点から $e_\vecf(v) \le -\Delta$ な頂点へのパス($\Delta$-残余パス)が存在しない (緩和されたカット条件)</li>
<li>$f_e \geq l_e + \Delta \Rightarrow c_e + p_u - p_v \leq 0, \quad \forall e = (u, v) \in E$ (緩和された相補性条件)</li>
<li>$f_e \leq u_e - \Delta \Rightarrow c_e + p_u - p_v \geq 0, \quad \forall e = (u, v) \in E$ (緩和された相補性条件)</li>
</ul>

<p>ここで, $G^\Delta_\vecf$ は $G_\vecf$ から容量が $\Delta$ 未満の辺を削除したものである.</p>

<p>容量が整数という条件の下, $\Delta = 1$ の時に元の問題と一致することに注意されたい. また, $\Delta$ が充分に大きいときは, 例えば $f_e = l_e, p_v = 0$ が上の条件を満たすことにも注意されたい.
容量スケーリング法は, 充分大きな $\Delta$ を取り, この $\Delta$-緩和された問題を解き, 得られた解を $\Delta/2$-緩和された問題の &quot;充分に良い&quot; 初期解に変形することを, $\Delta = 1$ になるまで繰り返すアルゴリズムである.
$\Delta$-緩和された問題の初期解が与えられた時, これを解くアルゴリズムは, Primal-Dual 法と同様, 次の2つのステップを交互に繰り返す. これを $\Delta$-scaling phase と呼ぶ.</p>

<ul>
<li>$\vec{f}$ は固定しておき, 緩和された相補性条件を保ちつつ $\vec{p}$ を変更することで, 双対目的関数値を改善する.</li>
<li>$\vec{p}$ は固定しておき, 緩和された相補性条件を保ちつつ $\vec{f}$ を変更することで, フローをより整合させる. すなわち $G^\Delta_\vecf$ 上での $e_\vecf(v) \ge +\Delta$ な頂点全体から $e_\vecf(v) \le -\Delta$ な頂点全体へのカット容量を小さくする.</li>
</ul>

<h3>補足</h3>

<p>上では主問題側の変数を $\Delta$-緩和した. 一方で双対問題側の変数を $\varepsilon$-緩和すると, 例えば</p>

<ul>
<li>$f_e > l_e \Rightarrow c_e + p_u - p_v \leq +\varepsilon, \quad \forall e = (u, v) \in E$ (緩和された相補性条件)</li>
<li>$f_e < u_e \Rightarrow c_e + p_u - p_v \geq -\varepsilon, \quad \forall e = (u, v) \in E$ (緩和された相補性条件)</li>
</ul>

<p>となる. これを用いると, コストスケーリング法 (Cost Scaling Algorithm) や平均長最小負閉路解消法 (Minimum Mean Cycle Cancel Algorithm) などが得られる.</p>

<h2>具体的なアルゴリズム</h2>

<p>以下の記号を使う.</p>

<ul>
<li>$G_\vecf$ は $\vecf$ に関する残余グラフ (逆辺を追加し, 残余容量 $0$ の辺を取り除いた, 容量が元のグラフの残余容量なグラフ)</li>
<li>$G^\Delta_\vecf$ は $G_\vecf$ のうち容量が $\Delta$ 以上のもののみからなるグラフ</li>
<li>$c^\vecp_e := c_e + p_u - p_v$</li>
<li>$e_\vecf(v) := b_v - (\sum_{e \in \delta^+(v)} f_e - \sum_{e \in \delta^-(v)} f_e)$</li>
</ul>

<p>今回紹介する容量スケーリング法は, 次のようなアルゴリズムである.</p>

<ol>
<li>$\U$ を $\max_e \{ u_e - l_e \}$ とし, $\Delta = 2^{\floor{\log_2 \U} + 1}$ とする.</li>
<li>$\vec{p} = \veczero$, $\vec{f} = \vec{l}$ とする.</li>
<li>$\Delta = 1$ なら終了し, そうでないならば $\Delta := \Delta / 2$ と更新する.</li>
<li>$c^\vecp_e < 0$ な $G^\Delta_\vecf$ の辺に対し, その辺が消える(残余容量が $\Delta$ 未満になる)まで $\Delta$ だけ push する.</li>
<li>&quot;$\Delta$-scaling phase&quot; を行う</li>
<li>3. に戻る</li>
</ol>

<p>$\Delta$-scaling phase は, 次の $\Delta$-scaling primal step と$\Delta$-scaling dual step を, $G^\Delta_\vecf$ に $e_\vecf(v) \ge +\Delta$ な頂点から $e_\vecf(v) \le -\Delta$ な頂点へのパスが無くなるまで行う.</p>

<p>$\Delta$-scaling primal step:</p>

<ol>
<li>$e_\vecf(v) \ge +\Delta$ な頂点から $e_\vecf(v) \le -\Delta$ な頂点へ $c^\vecp_e = 0$ な $G^\Delta_\vecf$ の辺からなるパスがあるならば, そのパスにそって $\Delta$ だけ push する.</li>
</ol>

<p>$\Delta$-scaling dual step:</p>

<ol>
<li>$G^\Delta_\vecf$ 上で $e_\vecf(v) \ge +\Delta$ な頂点から全点へのコスト $c^\vecp_e$ による (多始点)最短路長 $\vec{d}$ を求め, $\vecp := \vecp + \vec{d}$ と更新する.</li>
</ol>

<h2>実装</h2>

<p><a href="library_design.html">ぼくの考えたさいきょうのフローライブラリ</a> から, 前処理, メインループ, primal step, dual step を変更する.</p>

<h3>新しい前処理</h3>

<p>前処理では, 容量制約を守る $\vecf$ を一つとり, $\Delta$ の初期値を決める.</p>
<div class="highlight"><pre class="highlight cpp"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Status</span><span class="p">,</span> <span class="n">Cost</span><span class="o">&gt;</span> <span class="n">solve</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">potential</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">Flow</span> <span class="n">rcap</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">rcap</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">rcap</span><span class="p">);</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rcap</span><span class="p">;</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rcap</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Flow</span> <span class="n">inf_flow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="n">inf_flow</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">inf_flow</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">());</span>
    <span class="n">Flow</span> <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;=</span> <span class="n">inf_flow</span><span class="p">)</span> <span class="n">delta</span> <span class="o">*=</span> <span class="n">SCALING_FACTOR</span><span class="p">;</span>
    <span class="c1">// 続く</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>
<h3>メインループと各フェーズの前処理</h3>

<p>メインループは次のようになる.</p>
<div class="highlight"><pre class="highlight cpp"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>    <span class="k">for</span> <span class="p">(</span><span class="n">delta</span> <span class="o">/=</span> <span class="n">SCALING_FACTOR</span><span class="p">;</span> <span class="n">delta</span><span class="p">;</span> <span class="n">delta</span> <span class="o">/=</span> <span class="n">SCALING_FACTOR</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">saturate_negative</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">dual</span><span class="p">(</span><span class="n">delta</span><span class="p">))</span> <span class="n">primal</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
    <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>
<p>ここで, <code>saturate_negative</code> は次のような関数である.</p>
<div class="highlight"><pre class="highlight cpp"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>  <span class="kt">void</span> <span class="nf">saturate_negative</span><span class="p">(</span><span class="k">const</span> <span class="n">Flow</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">excess_vs</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">deficit_vs</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">Flow</span> <span class="n">rcap</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">();</span>
      <span class="k">const</span> <span class="n">Cost</span> <span class="n">rcost</span> <span class="o">=</span> <span class="n">residual_cost</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">rcost</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rcap</span> <span class="o">&gt;=</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">rcap</span><span class="p">);</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rcap</span><span class="p">;</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rcap</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">V_id</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">excess_vs</span> <span class="o">:</span> <span class="n">deficit_vs</span><span class="p">).</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>
<h3>dual step</h3>

<p>ほぼ, Primal-Dual におけるフロー型の <code>0</code> との比較を $\Delta$ との比較に変えただけ.</p>
<div class="highlight"><pre class="highlight cpp"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre>  <span class="kt">bool</span> <span class="nf">dual</span><span class="p">(</span><span class="k">const</span> <span class="n">Flow</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dist</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">unreachable</span><span class="p">);</span>
    <span class="n">parent</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
    <span class="n">excess_vs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove_if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">excess_vs</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">excess_vs</span><span class="p">),</span>
                                   <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">;</span> <span class="p">}),</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">excess_vs</span><span class="p">));</span>
    <span class="n">deficit_vs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove_if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">deficit_vs</span><span class="p">),</span>
                                    <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">deficit_vs</span><span class="p">),</span>
                                    <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">delta</span><span class="p">;</span> <span class="p">}),</span>
                     <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">deficit_vs</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">v</span> <span class="o">:</span> <span class="n">excess_vs</span><span class="p">)</span> <span class="n">pq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="n">farthest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">deficit_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
      <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="n">farthest</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">delta</span><span class="p">)</span> <span class="o">++</span><span class="n">deficit_count</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">deficit_count</span> <span class="o">&gt;=</span> <span class="n">deficit_vs</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">new_dist</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">residual_cost</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">new_dist</span> <span class="o">&gt;=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_dist</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="k">decltype</span><span class="p">(</span><span class="n">pq</span><span class="p">)();</span> <span class="c1">// pq.clear() doesn't exist.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">V_id</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">potential</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">farthest</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">deficit_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>
<h3>primal step</h3>

<p>こちらも同様. $\Delta$ 以上しか流さないようにしていることに注意.</p>
<div class="highlight"><pre class="highlight cpp"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>  <span class="kt">void</span> <span class="nf">primal</span><span class="p">(</span><span class="k">const</span> <span class="n">Flow</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">t</span> <span class="o">:</span> <span class="n">deficit_vs</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">farthest</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="n">Flow</span> <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>
      <span class="n">V_id</span> <span class="n">v</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">f</span> <span class="o">&gt;=</span> <span class="n">delta</span><span class="p">;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">residual_cap</span><span class="p">());</span>
      <span class="p">}</span>
      <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">;)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">=</span> <span class="o">*</span><span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
        <span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
        <span class="k">const</span> <span class="kt">size_t</span> <span class="n">u</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">;</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">b</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f</span><span class="p">;</span>
      <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>
<h2>計算量</h2>

<p>primal step は $O(m)$, dual step は $O(m \log m)$ である.</p>

<p>$\U$ を $\max_e \{ u_e - l_e \}$ とすると, $\Delta$ の初期値は $O(\U)$ であり, 合計 $O(\log \U)$ 回の scaling phase がある.</p>

<p>$\Delta$-scaling phase で流すフロー量を $F_\Delta$ とする.
フェーズ末尾を除く各 dual step につき, 少なくとも $\Delta$ だけフローを流すから, 上の実装は $O ( \sum_\Delta (F_\Delta / \Delta) m \log m )$ になる.
この $F_\Delta$ について考える.</p>

<p>大雑把に言うと, 次の2つを示す:</p>

<ul>
<li>フェーズの前処理で追加されるフローの不整合度合いは $O(m \Delta)$ である.</li>
<li>前のフェーズから残っているフローの不整合度合いのうち, 解決出来るのは $O(m \Delta)$ である.</li>
</ul>

<p>さて, $\Delta$ を一つ固定し, $\Delta$-scaling phase の前処理を行う直前 ($2\Delta$-scaling phase の直後又は初回) のフローを $\vecf'$, 前処理の直後のフローを $\vecf$ とし, (前処理でポテンシャルは不変なので両方に)対応するポテンシャルを $\vecp$ とすると,</p>

<ul>
<li>$G^{2\Delta}_{\vecf'}$ 上に $e_{\vecf'}(v) \ge +2\Delta$ な頂点から $e_{\vecf'}(v) \le -2\Delta$ な頂点へのパス($2\Delta$-残余パス)が存在しない (緩和されたカット条件)</li>
<li>$c^\vecp_e > 0 \Rightarrow f'_e < l_e + 2 \Delta, \quad \forall e = (u, v) \in E$ (緩和された相補性条件の対偶)</li>
<li>$c^\vecp_e < 0 \Rightarrow f'_e > u_e - 2 \Delta, \quad \forall e = (u, v) \in E$ (緩和された相補性条件の対偶)</li>
</ul>

<p>が成り立つ. 各 primal step では $e_\vecf(v) \ge +\Delta$ な頂点から $e_\vecf(v) \le -\Delta$ な頂点にフローを流す. この始点/終点になりうる頂点を4つに分割し,</p>

<ul>
<li>$e_{\vecf'}(v) \ge + 2 \Delta$ かつ $e_\vecf(v) \ge + \Delta$ な頂点全体の集合を $A$,</li>
<li>$e_{\vecf'}(v) \le - 2 \Delta$ かつ $e_\vecf(v) \le - \Delta$ な頂点全体の集合を $B$,</li>
<li>上のどれでもなく前処理後 $e_\vecf(v) \ge +\Delta$ な頂点全体の集合を $C$,</li>
<li>上のどれでもなく前処理後 $e_\vecf(v) \le -\Delta$ な頂点全体の集合を $D$</li>
</ul>

<p>とすると, $F_\Delta$ は $A \cup C$ から $B \cup D$ に流れることになる.</p>

<p>$\Delta$-scaling phase の前処理は
$c^\vecp_e > 0$ な辺で $f_e = l_e$,
$c^\vecp_e < 0$ な辺で $f_e = u_e$
となるように各辺 $e$ に push するから, $(\vecf', \vecp)$ に対する相補性条件から, 各辺 $e$ で $|f_e - f'_e| < 2 \Delta$ であり, $\sum_v |e_{\vecf'}(v) - e_\vecf(v)| < 4 m \Delta$ である.
$C$ と $D$ は $\abs{e_{\vecf'}(v)} < 2 \Delta$ か $\abs{e_\vecf(v)} < \Delta$ を満たすから, $C$ と $D$ に対する $|e_\vecf(v)|$ の合計は $O((n + m) \Delta)$ である.
従って, $A$ から $D$, $C$ から $B$, $C$ から $D$ に流すフロー量の合計は $O((n + m) \Delta) = O(m \Delta)$.</p>

<p>一方, $A$ から $B$ は $G^{2 \Delta}_{\vecf'}$ 上に パスが存在しない.
従って, $G_{\vecf'}$ 上での最小 $A$-$B$ カットの容量は $O(m \Delta)$ である.
$|f_e - f'_e| < 2 \Delta$ であったから, $G_{\vecf}$ での最小 $A$-$B$ カットの容量も $O(m \Delta)$ であり, $A$ から $B$ に流すフロー量の合計は $O(\Delta m)$.</p>

<p>以上を纏めて, $F_\Delta = O(\Delta m)$, 従って全フェーズ合わせて $O ( \sum_\Delta (F_\Delta / \Delta) m \log m ) = O(\sum_\Delta m^2 \log m) = O(m^2 \log m \log \U)$ である.</p>

<p>scaling factor を $2$ ではなく $\alpha$ とすると, $O(m^2 \alpha \log_\alpha \U \log m)$ である.</p>

<h3>注意</h3>

<p>Z. Király and P. Kovács (2012) の Capacity Scaling (CAS) は恐らく上記のアルゴリズムとほぼ同じであるが,
これはよく知られた Capacity Scaling Algorithm から前処理を少し削っている.
そして &quot;In this case, the polynomial running time bound is not proved&quot; とあるので, 上の僕の証明は間違っているかもしれない...</p>

<p>さて, 教科書的な容量スケーリング法では, 任意の頂点対 $(u, v)$ に対し, $u$ から $v$ への充分大きな容量の辺があることを仮定する. (これは前処理でコスト $\infty$ として追加すれば容易に満たせる)
この仮定の下, 各 $\Delta$-scaling phase は $e_\vecf(v) \ge +\Delta$ となる頂点か $e_\vecf(v) \le -\Delta$ となる頂点が無くなることにより終了する事が示せる.
これを用いると, 上でいう $A$ から $B$ に流れるフローを考える必要がなくなり, 証明がより簡単になる.
上の証明が正しく無さそうだと思う人は, この前処理を入れるとよいだろう.</p>

<h2>参考文献</h2>

<ol>
<li><a href="https://doi.org/10.1145/62212.62249">J.B.Orlin, &quot;A faster strongly polynomial minimum cost flow algorithm&quot;, Oper. Res. 41 (1993) 338-350.</a></li>
<li><a href="https://www.amazon.co.jp/dp/013617549X" title="Network Flows: Theory, Algorithms, and Applications">R.K.Ahuja, T.L.Magnanti, J.B.Orlin, &quot;Network Flows: Theory, Algorithms, and Applications&quot;, Prentice-Hall, Inc., 1993.</a></li>
<li><a href="https://arxiv.org/abs/1207.6381">Z. Király, P. Kovács, &quot;Efficient implementations of minimum-cost flow algorithms&quot;, Acta Universitatis Sapientiae, Informatica, 4, 1 (2012) 67-118.</a></li>
</ol>

<ul>
<li>1. はちゃんと読んでいないが, 容量 $\infty$ なものについて扱い, その後輸送問題への変形を使って有限容量に対応しているようだ.</li>
<li>2. では 10.2 節で扱われている. ちゃんと書いていないが, $\Delta$-scaling phase の終了条件の正当性に Assumption 9.4 (上の注意で言った仮定)が効いている.</li>
<li>3. で上記の注意が出てくる. &quot;証明されていないが, この実装の方が有意に速かったのでこっちを使った&quot; という旨が書かれている.</li>
</ul>

<h2>ソースコード</h2>

<pre class='fold_button'>長いので折りたたみ</pre>

<pre class='fold_begin'></pre>
<div class="highlight"><pre class="highlight cpp"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cstdint&gt;
#include &lt;numeric&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
</span>
<span class="k">enum</span> <span class="n">Objective</span> <span class="p">{</span>
    <span class="n">MINIMIZE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">MAXIMIZE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">Status</span> <span class="p">{</span>
    <span class="n">OPTIMAL</span><span class="p">,</span>
    <span class="n">INFEASIBLE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Flow</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Cost</span><span class="p">,</span> <span class="n">Objective</span> <span class="n">objective</span> <span class="o">=</span> <span class="n">Objective</span><span class="o">::</span><span class="n">MINIMIZE</span><span class="p">,</span> <span class="n">Flow</span> <span class="n">SCALING_FACTOR</span> <span class="o">=</span> <span class="mi">2</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">MinCostFlow</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">V_id</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">E_id</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">Edge</span> <span class="p">{</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">MinCostFlow</span><span class="p">;</span>

    <span class="n">V_id</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">;</span>
    <span class="n">Flow</span> <span class="n">flow</span><span class="p">,</span> <span class="n">cap</span><span class="p">;</span>
    <span class="n">Cost</span> <span class="n">cost</span><span class="p">;</span>
    <span class="n">E_id</span> <span class="n">rev</span><span class="p">;</span>

  <span class="nl">public:</span>
    <span class="n">Edge</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">Edge</span><span class="p">(</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">V_id</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">Flow</span> <span class="n">cap</span><span class="p">,</span> <span class="k">const</span> <span class="n">Cost</span> <span class="n">cost</span><span class="p">,</span>
         <span class="k">const</span> <span class="n">E_id</span> <span class="n">rev</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">src</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">dst</span><span class="p">(</span><span class="n">dst</span><span class="p">),</span> <span class="n">flow</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">cap</span><span class="p">(</span><span class="n">cap</span><span class="p">),</span> <span class="n">cost</span><span class="p">(</span><span class="n">cost</span><span class="p">),</span> <span class="n">rev</span><span class="p">(</span><span class="n">rev</span><span class="p">)</span> <span class="p">{}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">Flow</span> <span class="n">residual_cap</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">cap</span> <span class="o">-</span> <span class="n">flow</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">};</span>

<span class="nl">public:</span>

  <span class="k">class</span> <span class="nc">EdgePtr</span> <span class="p">{</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">MinCostFlow</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">MinCostFlow</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">E_id</span> <span class="n">e</span><span class="p">;</span>

    <span class="n">EdgePtr</span><span class="p">(</span><span class="k">const</span> <span class="n">MinCostFlow</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">E_id</span> <span class="n">e</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">instance</span><span class="p">(</span><span class="n">instance</span><span class="p">),</span> <span class="n">v</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">e</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">edge</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">e</span><span class="p">];</span> <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">rev</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">=</span> <span class="n">edge</span><span class="p">();</span>
      <span class="k">return</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">][</span><span class="n">e</span><span class="p">.</span><span class="n">rev</span><span class="p">];</span>
    <span class="p">}</span>

  <span class="nl">public:</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">V_id</span> <span class="n">src</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">rev</span><span class="p">().</span><span class="n">dst</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">V_id</span> <span class="n">dst</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">edge</span><span class="p">().</span><span class="n">dst</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">Flow</span> <span class="n">flow</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">edge</span><span class="p">().</span><span class="n">flow</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">Flow</span> <span class="n">lower</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">rev</span><span class="p">().</span><span class="n">cap</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">Flow</span> <span class="n">upper</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">edge</span><span class="p">().</span><span class="n">cap</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">Cost</span> <span class="n">cost</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">edge</span><span class="p">().</span><span class="n">cost</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">Cost</span> <span class="n">gain</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">edge</span><span class="p">().</span><span class="n">cost</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">};</span>

<span class="nl">private:</span>
  <span class="n">V_id</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&gt;</span> <span class="n">g</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Flow</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="n">MinCostFlow</span><span class="p">()</span> <span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">V_id</span> <span class="n">add_vertex</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">n</span><span class="p">;</span>
    <span class="n">g</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">b</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">V_id</span><span class="o">&gt;</span> <span class="n">add_vertices</span><span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">V_id</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">V_id</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">ret</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">g</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">b</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">EdgePtr</span> <span class="n">add_edge</span><span class="p">(</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">V_id</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">Flow</span> <span class="n">lower</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">Flow</span> <span class="n">upper</span><span class="p">,</span> <span class="k">const</span> <span class="n">Cost</span> <span class="n">cost</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">E_id</span> <span class="n">e</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">src</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="n">re</span> <span class="o">=</span> <span class="n">src</span> <span class="o">==</span> <span class="n">dst</span> <span class="o">?</span> <span class="n">e</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">dst</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lower</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="p">);</span>
    <span class="n">g</span><span class="p">[</span><span class="n">src</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Edge</span><span class="p">{</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">cost</span> <span class="o">*</span> <span class="n">objective</span><span class="p">,</span> <span class="n">re</span><span class="p">});</span>
    <span class="n">g</span><span class="p">[</span><span class="n">dst</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Edge</span><span class="p">{</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="o">-</span><span class="n">lower</span><span class="p">,</span> <span class="o">-</span><span class="n">cost</span> <span class="o">*</span> <span class="n">objective</span><span class="p">,</span> <span class="n">e</span><span class="p">});</span>
    <span class="k">return</span> <span class="n">EdgePtr</span><span class="p">{</span><span class="k">this</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">e</span><span class="p">};</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">add_supply</span><span class="p">(</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">Flow</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">amount</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">add_demand</span><span class="p">(</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">Flow</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="c1">// Variables used in calculation</span>
  <span class="k">static</span> <span class="n">Cost</span> <span class="k">constexpr</span> <span class="n">unreachable</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">Cost</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
  <span class="n">Cost</span> <span class="n">farthest</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Cost</span><span class="o">&gt;</span> <span class="n">potential</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Cost</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span> <span class="o">*&gt;</span> <span class="n">parent</span><span class="p">;</span> <span class="c1">// out-forrest.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Cost</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Cost</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span>
                      <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;&gt;&gt;</span>
      <span class="n">pq</span><span class="p">;</span> <span class="c1">// should be empty outside of dual()</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">V_id</span><span class="o">&gt;</span> <span class="n">excess_vs</span><span class="p">,</span> <span class="n">deficit_vs</span><span class="p">;</span>

  <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">rev</span><span class="p">(</span><span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">][</span><span class="n">e</span><span class="p">.</span><span class="n">rev</span><span class="p">];</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">Edge</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="n">Flow</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">e</span><span class="p">.</span><span class="n">flow</span> <span class="o">+=</span> <span class="n">amount</span><span class="p">;</span>
    <span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">][</span><span class="n">e</span><span class="p">.</span><span class="n">rev</span><span class="p">].</span><span class="n">flow</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Cost</span> <span class="n">residual_cost</span><span class="p">(</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">V_id</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">e</span><span class="p">.</span><span class="n">cost</span> <span class="o">+</span> <span class="n">potential</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">-</span> <span class="n">potential</span><span class="p">[</span><span class="n">dst</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">dual</span><span class="p">(</span><span class="k">const</span> <span class="n">Flow</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dist</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">unreachable</span><span class="p">);</span>
    <span class="n">parent</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
    <span class="n">excess_vs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove_if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">excess_vs</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">excess_vs</span><span class="p">),</span>
                                   <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">;</span> <span class="p">}),</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">excess_vs</span><span class="p">));</span>
    <span class="n">deficit_vs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove_if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">deficit_vs</span><span class="p">),</span>
                                    <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">deficit_vs</span><span class="p">),</span>
                                    <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">delta</span><span class="p">;</span> <span class="p">}),</span>
                     <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">deficit_vs</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">v</span> <span class="o">:</span> <span class="n">excess_vs</span><span class="p">)</span> <span class="n">pq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="n">farthest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">deficit_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
      <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="n">farthest</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">delta</span><span class="p">)</span> <span class="o">++</span><span class="n">deficit_count</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">deficit_count</span> <span class="o">&gt;=</span> <span class="n">deficit_vs</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">new_dist</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">residual_cost</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">new_dist</span> <span class="o">&gt;=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_dist</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="k">decltype</span><span class="p">(</span><span class="n">pq</span><span class="p">)();</span> <span class="c1">// pq.clear() doesn't exist.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">V_id</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">potential</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">farthest</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">deficit_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">primal</span><span class="p">(</span><span class="k">const</span> <span class="n">Flow</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">t</span> <span class="o">:</span> <span class="n">deficit_vs</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">farthest</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="n">Flow</span> <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>
      <span class="n">V_id</span> <span class="n">v</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">f</span> <span class="o">&gt;=</span> <span class="n">delta</span><span class="p">;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">residual_cap</span><span class="p">());</span>
      <span class="p">}</span>
      <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">;)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">=</span> <span class="o">*</span><span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
        <span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
        <span class="k">const</span> <span class="kt">size_t</span> <span class="n">u</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">;</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">b</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f</span><span class="p">;</span>
      <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">saturate_negative</span><span class="p">(</span><span class="k">const</span> <span class="n">Flow</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">excess_vs</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">deficit_vs</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">Flow</span> <span class="n">rcap</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">();</span>
      <span class="k">const</span> <span class="n">Cost</span> <span class="n">rcost</span> <span class="o">=</span> <span class="n">residual_cost</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">rcost</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rcap</span> <span class="o">&gt;=</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">rcap</span><span class="p">);</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rcap</span><span class="p">;</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rcap</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">V_id</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">excess_vs</span> <span class="o">:</span> <span class="n">deficit_vs</span><span class="p">).</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="nl">public:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Status</span><span class="p">,</span> <span class="n">Cost</span><span class="o">&gt;</span> <span class="n">solve</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">potential</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">Flow</span> <span class="n">rcap</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">rcap</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">rcap</span><span class="p">);</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rcap</span><span class="p">;</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rcap</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Flow</span> <span class="n">inf_flow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="n">inf_flow</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">inf_flow</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">());</span>
    <span class="n">Flow</span> <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;=</span> <span class="n">inf_flow</span><span class="p">)</span> <span class="n">delta</span> <span class="o">*=</span> <span class="n">SCALING_FACTOR</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">delta</span> <span class="o">/=</span> <span class="n">SCALING_FACTOR</span><span class="p">;</span> <span class="n">delta</span><span class="p">;</span> <span class="n">delta</span> <span class="o">/=</span> <span class="n">SCALING_FACTOR</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">saturate_negative</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">dual</span><span class="p">(</span><span class="n">delta</span><span class="p">))</span> <span class="n">primal</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Cost</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">value</span> <span class="o">+=</span> <span class="n">e</span><span class="p">.</span><span class="n">flow</span> <span class="o">*</span> <span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">value</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">excess_vs</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">deficit_vs</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span> <span class="n">Status</span><span class="o">::</span><span class="n">OPTIMAL</span><span class="p">,</span> <span class="n">value</span> <span class="o">/</span> <span class="n">objective</span> <span class="p">};</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span> <span class="n">Status</span><span class="o">::</span><span class="n">INFEASIBLE</span><span class="p">,</span> <span class="n">value</span> <span class="o">/</span> <span class="n">objective</span> <span class="p">};</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Flow</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Cost</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">MaxGainFlow</span> <span class="o">=</span> <span class="n">MinCostFlow</span><span class="o">&lt;</span><span class="n">Flow</span><span class="p">,</span> <span class="n">Cost</span><span class="p">,</span> <span class="n">Objective</span><span class="o">::</span><span class="n">MAXIMIZE</span><span class="o">&gt;</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div>
<pre class='fold_end'></pre>

<h2>使用例</h2>

<h3>Library-Checker: Minimum cost b-flow</h3>

<p>問題は<a href="https://judge.yosupo.jp/problem/min_cost_b_flow">こちら</a></p>

<pre class='fold_button'>長いので折りたたみ</pre>

<pre class='fold_begin'></pre>
<div class="highlight"><pre class="highlight cpp"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
</pre></td><td class="rouge-code"><pre><span class="k">namespace</span> <span class="n">methods_to_add</span> <span class="p">{</span>
  <span class="c1">// 以下の3つの関数を MinCostFlow クラスに追加する</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">T</span> <span class="n">get_result_value</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">value</span> <span class="o">+=</span> <span class="p">(</span><span class="n">T</span><span class="p">)(</span><span class="n">e</span><span class="p">.</span><span class="n">flow</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">T</span><span class="p">)(</span><span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">value</span> <span class="o">/=</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">value</span> <span class="o">/</span> <span class="n">objective</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Cost</span><span class="o">&gt;</span> <span class="n">get_potential</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Not strictly necessary, but re-calculate potential to bound the potential values,</span>
    <span class="c1">// plus make them somewhat canonical so that it is robust for the algorithm chaneges.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">potential</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">potential</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">potential</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">potential</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">],</span> <span class="n">potential</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">potential</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">get_cut</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">excess_vs</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">deficit_vs</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">unreachable</span><span class="p">))</span>
        <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#include &lt;cstdint&gt;
#include &lt;cstdio&gt;
#include &lt;set&gt;
#include &lt;string&gt;
</span>
<span class="cp">#define REP(i, b, n) for (int i = (int)(b); i &lt; (int)(n); ++i)
#define rep(i, n) REP(i, 0, n)
#define loop(n) rep(i##__COUNTER__, n)
</span>
<span class="kt">int</span> <span class="nf">readI</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="nf">readLL</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">"%lld"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">i2s</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="s">"-"</span> <span class="o">+</span> <span class="n">i2s</span><span class="p">(</span><span class="o">-</span><span class="n">value</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="s">"0"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="sc">'0'</span> <span class="o">+</span> <span class="p">(</span><span class="n">value</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span>
    <span class="n">value</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">Flow</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">Cost</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">MCF</span> <span class="o">=</span> <span class="n">MinCostFlow</span><span class="o">&lt;</span><span class="n">Flow</span><span class="p">,</span> <span class="n">Cost</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">readI</span><span class="p">();</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">readI</span><span class="p">();</span>
  <span class="n">MCF</span> <span class="n">mcf</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">vs</span> <span class="o">=</span> <span class="n">mcf</span><span class="p">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Flow</span><span class="o">&gt;</span> <span class="n">original_bs</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="n">rep</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">Flow</span> <span class="n">b</span> <span class="o">=</span> <span class="n">readLL</span><span class="p">();</span>
    <span class="n">original_bs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">mcf</span><span class="p">.</span><span class="n">add_supply</span><span class="p">(</span><span class="n">vs</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MCF</span><span class="o">::</span><span class="n">EdgePtr</span><span class="o">&gt;</span> <span class="n">edges</span><span class="p">;</span>
  <span class="n">loop</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">readI</span><span class="p">();</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">readI</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Flow</span> <span class="n">lower</span> <span class="o">=</span> <span class="n">readLL</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Flow</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">readLL</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Cost</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">readLL</span><span class="p">();</span>
    <span class="n">edges</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">mcf</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">cost</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">status</span> <span class="o">=</span> <span class="n">mcf</span><span class="p">.</span><span class="n">solve</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">Status</span><span class="o">::</span><span class="n">INFEASIBLE</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">cut_vec</span> <span class="o">=</span> <span class="n">mcf</span><span class="p">.</span><span class="n">get_cut</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">cut_set</span><span class="p">(</span><span class="n">cut_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">cut_vec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">Flow</span> <span class="n">left_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cap_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">rep</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">cut_set</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">?</span> <span class="n">left_sum</span> <span class="o">:</span> <span class="n">right_sum</span><span class="p">)</span> <span class="o">+=</span> <span class="n">original_bs</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="k">auto</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">cut_set</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">const</span> <span class="k">auto</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">cut_set</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">sl</span> <span class="o">!=</span> <span class="n">tr</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">sl</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cap_sum</span> <span class="o">+=</span> <span class="n">e</span><span class="p">.</span><span class="n">upper</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">cap_sum</span> <span class="o">-=</span> <span class="n">e</span><span class="p">.</span><span class="n">lower</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">left_sum</span> <span class="o">&gt;</span> <span class="n">cap_sum</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">right_sum</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cap_sum</span><span class="p">));</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"infeasible"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">potential</span> <span class="o">=</span> <span class="n">mcf</span><span class="p">.</span><span class="n">get_potential</span><span class="p">();</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">result_value</span> <span class="o">=</span> <span class="n">mcf</span><span class="p">.</span><span class="n">get_result_value</span><span class="o">&lt;</span><span class="n">__int128_t</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">puts</span><span class="p">(</span><span class="n">i2s</span><span class="p">(</span><span class="n">result_value</span><span class="p">).</span><span class="n">c_str</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">v</span> <span class="o">:</span> <span class="n">vs</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="n">i2s</span><span class="p">(</span><span class="n">potential</span><span class="p">[</span><span class="n">v</span><span class="p">]).</span><span class="n">c_str</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="n">i2s</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">flow</span><span class="p">()).</span><span class="n">c_str</span><span class="p">());</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>
<pre class='fold_end'></pre>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>厳密にはこの2つは異なる(例えば<a href="https://www.amazon.co.jp/dp/013617549X" title="Network Flows: Theory, Algorithms, and Applications">蜘蛛の巣本</a>)が, この記事では深く言及しない.&nbsp;<a href="#fnref1">&#8617;</a></p>
</li>

<li id="fn2">
<p>ここでは最小費用 $\vecb$-フロー問題を採用する.&nbsp;<a href="#fnref2">&#8617;</a></p>
</li>

<li id="fn3">
<p>一般的にどう呼ばれるか知らないので, ここではカット条件と呼ぶことにする.&nbsp;<a href="#fnref3">&#8617;</a></p>
</li>

</ol>
</div>


      <h3>Tags</h3>
        <div class='tag'><a href="../../tags/フロー.html">フロー</a></div>
        <div class='tag'><a href="../../tags/最小費用流.html">最小費用流</a></div>
  </div>
  </body>
</html>
