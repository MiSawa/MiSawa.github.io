<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<title>容量スケーリング法のすゝめ - みさわめも</title>
<meta name="description" content="最小費用流問題に対する、単純な割に高速なアルゴリズムの一つである容量スケーリング法の実装と解説。" />
<meta itemprop="name" content="容量スケーリング法のすゝめ" />
<meta itemprop="description" content="最小費用流問題に対する、単純な割に高速なアルゴリズムの一つである容量スケーリング法の実装と解説。" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@Mi_Sawa" />
<meta name="twitter:title" content="容量スケーリング法のすゝめ" />
<meta name="twitter:description" content="最小費用流問題に対する、単純な割に高速なアルゴリズムの一つである容量スケーリング法の実装と解説。" />
<meta property="og:type" content="website" />
<meta property="og:title" content="容量スケーリング法のすゝめ" />
<meta property="og:description" content="最小費用流問題に対する、単純な割に高速なアルゴリズムの一つである容量スケーリング法の実装と解説。" />
<meta property="og:site_name" content="みさわめも" />
<meta property="og:locale" content="ja_JP" />
<meta name="twitter:creator" content="@Mi_Sawa" />

    <link href="../../stylesheets/normalize-672beeec.css" rel="stylesheet" /><link href="../../stylesheets/all-6c69f2b3.css" rel="stylesheet" /><link href="../../stylesheets/rouge-1aec61e0.css" rel="stylesheet" />
    <script>
  window.WebFontConfig = {
    custom: {
      families: ['KaTeX_AMS', 'KaTeX_Caligraphic:n4,n7', 'KaTeX_Fraktur:n4,n7',
        'KaTeX_Main:n4,n7,i4,i7', 'KaTeX_Math:i4,i7', 'KaTeX_Script',
        'KaTeX_SansSerif:n4,n7,i4', 'KaTeX_Size1', 'KaTeX_Size2', 'KaTeX_Size3',
        'KaTeX_Size4', 'KaTeX_Typewriter'],
    },
  };
</script>
<script defer src="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.js" integrity="sha256-4O4pS1SH31ZqrSO2A/2QJTVjTPqVe+jnYgOWUVr7EEc=" crossorigin="anonymous"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    renderMathInElement(document.body, {
      delimiters: [
        {left: "$$", right: "$$", display: true},
        {left: "$", right: "$", display: false},
        {left: "\\(", right: "\\)", display: false},
        {left: "\\[", right: "\\]", display: true},
      ],
      macros: {
        // '\\N': '{\\mathbb{N}}',
        // '\\Z': '{\\mathbb{Z}}',
        '\\Q': '{\\mathbb{Q}}',
        // '\\R': '{\\mathbb{R}}',
        '\\C': '{\\mathbb{C}}',
        '\\divides': '{\\mid}',
        '\\abs': '{\\left| #1 \\right|}',
        '\\relmiddle': '\\mathrel{}\\middle#1\\mathrel{}',
        '\\setmid': '\\relmiddle|',
        '\\set': '\\left\\{\\,#1\\,\\right\\}',
      },
    });
  });
</script>



      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-25117970-3"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-25117970-3');
        gtag('config', 'G-L8X6JXB71M');
      </script>
  </head>

  <body class='others others_flow others_flow_lets_use_capacity_scaling'>
    <header>
      <input id='nav-hamburger-checkbox' type='checkbox' />
      <label id='nav-hamburger-button' for='nav-hamburger-checkbox'>
        <svg id="menu-toggle-icon" style="enable-background:new 0 0 32 32;" version="1.1" viewBox="0 0 32 32" height="32px" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
          <title>Icon to toggle menu</title>
          <g class='hamburger' fill="none" stroke="black" stroke-width="4">
            <path stroke-linecap="round" d="M4,8h24"/>
            <path stroke-linecap="round" d="M4,16h24"/>
            <path stroke-linecap="round" d="M4,24h24"/>
          </g>
          <g class='close' fill="none" stroke="black" stroke-width="4">
            <path stroke-linecap="round" d="M8,8l16,16"/>
            <path stroke-linecap="round" d="M8,24l16,-16"/>
          </g>
      </label>
      <nav>
        <ul>
            <li> <a href="../../index.html">Top</a> </li>
            <li> <a href="../../contests.html">Contests</a> </li>
            <li> <a href="../index.html">Articles</a> </li>
            <li> <a href="../../tags/index.html">Tags</a> </li>
            <li> <a href="../../about.html">About</a> </li>
      </nav>
    </header>

    <main>

      <article>
            <div style="display:none">`$$
\gdef\vec#1{\mathbf{#1}}
\gdef\vecb{\vec{b}}
\gdef\vecf{\vec{f}}
\gdef\vecp{\vec{p}}
\gdef\veczero{\vec{0}}
\gdef\U{\mathcal{U}}
\gdef\floor#1{\lfloor #1 \rfloor}
\gdef\exE{\overleftrightarrow{E}}
\gdef\reve{\overleftarrow{e}}
$$`</div>

<h1>容量スケーリング法のすゝめ</h1>

<h2>要約</h2>

<ul>
  <li>最小費用流問題に対する最短路反復法(Successive Shortest Path, SSP)や Primal-Dual 法<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup>と呼ばれるアルゴリズムは, 少し弄ると弱多項式時間アルゴリズムにできる.</li>
  <li>具体的には, $O(\U \cdot \mathrm{SP_+}(n, m, nC))$ が $O(m \log \U \cdot \mathrm{SP_+}(n, m, nC))$ になる.</li>
  <li>$\mathrm{SP_+}(n, m, nC)$ は$n$ 頂点 $m$ 辺, 費用高々 $nC$ のグラフの一点から全点への最短路問題を解くのにかかる時間. 以下では実装をサボったダイクストラ法なので $O(m \log m)$ だが, $\exists k: m = O(n^k)$ を仮定すると合計 $O(m^2 \log \U \log n)$.</li>
</ul>

<h2>まえがき</h2>
<p><a href="library_design.html">ぼくの考えたさいきょうのフローライブラリ</a> では, その速さは特に追求せず, SSP を用いたライブラリの設計例を紹介した.
この記事では, 前回完成したライブラリを少し変更することで, 計算量を改善する.</p>

<p>よく教科書に乗っている容量スケーリング法とは, ちょっとだけ形を変えた実装になっている.
書いた後に参考文献を漁っていたら, <em>この形の実装だと多項式時間な計算量が証明されていない</em> とか見つけたので, もし僕の証明が間違っていたらごめんなさい.
この形で多項式時間を示している文献を知っている方, もしくは間違えているところを見つけ方は, そっと報告してくれると喜びます.
正しいことが (僕以外の人の手によって) 知られている前処理方法についても, 最後に言及します.</p>

<p>実装のみを知りたい方は, 前半の章は読み飛ばして下さい.</p>

<h2>背景知識</h2>
<p>計算量解析で必要なものの準備を兼ねて, LP と容量スケーリング法のかかわりと, 容量スケーリング法の invariant を見る.</p>

<h3>記号の準備</h3>
<p>問題の定義すらまだだけれど, 先においておいた方が後で見やすいと思うので.</p>

<ul>
  <li>$\exE$ は $E$ に逆辺を追加した集合</li>
  <li>$u_\vecf(e)$ は残余容量 (順辺に対しては $u_\vecf(e) := u_e - f_e$, 逆辺については $u_\vecf(\reve) := f_e - l_e$)</li>
  <li>$c^\vecp(e)$ は簡約コスト(順辺 $e = (u, v)$ に対しては $c^\vecp(e) := c_e + p_u - p_v$, 逆辺については $c^\vecp(\reve) := -c^\vecp(e)$)</li>
  <li>$G_\vecf$ は $\vecf$ に関する残余グラフ ($\exE$ のうち $u_\vecf(e) > 0$ なものを集めたもの. 容量は $u_\vecf(e)$.)</li>
  <li>$G^\Delta_\vecf$ は $G_\vecf$ のうち容量が $\Delta$ 以上のもののみからなるグラフ</li>
  <li>$\U := \max_e \{ u_e - l_e \}$</li>
  <li>$\delta^+(v)$ は $v$ から出る $G$ の辺全体の集合, $\delta^-(v)$ は $v$ へ入る $G$ の辺全体の集合.</li>
  <li>$e_\vecf(v) := b_v - (\sum_{e \in \delta^+(v)} f_e - \sum_{e \in \delta^-(v)} f_e)$ (余剰量)</li>
  <li>$S_\vecf := \{ v | e_\vecf(v) > 0 \}$, $T_\vecf := \{ v | e_\vecf(v) < 0 \}$</li>
  <li>$S^\Delta_\vecf := \{ v | e_\vecf(v) \ge +\Delta \}$, $T^\Delta_\vecf := \{ v | e_\vecf(v) \le -\Delta \}$</li>
</ul>

<h3>LP と Primal-Dual 法</h3>
<p>最小費用流問題<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote">2</a></sup>は, その線型計画問題としての表現と強双対性を使うと, 次のような問題と捉えられる;</p>

<p>与えられた有向グラフ $G = (V, E)$ と, $\sum_v b_v = 0$ であるような $\vec{b} = \{b_v\}_{v \in V}$, $l_e \le u_e$ であるような $\vec{l} = \{l_e\}_{e \in E}$ と $\vec{u} = \{u_e\}_{e \in E}$, $\vec{c} = \{c_e\}_{e \in E}$ の組 $(G, \vec{b}, \vec{l}, \vec{u}, \vec{c})$ に対し,
$\vec{f} = \{f_e\}_{e \in E}$, $\vec{p} = \{p_v\}_{v \in V}$ で, 次を満たすものを求めよ.</p>

<ul>
  <li>$l_e \leq f_e \leq u_e, \quad \forall e \in E$ (容量制約)</li>
  <li>$\sum_{e \in \delta^+(v)} f_e - \sum_{e \in \delta^-(v)} f_e = b_v, \quad \forall v \in V$ (フロー整合性条件)</li>
  <li>$f_e > l_e \Rightarrow c_e + p_u - p_v \leq 0, \quad \forall e = (u, v) \in E$ (相補性条件)</li>
  <li>$f_e < u_e \Rightarrow c_e + p_u - p_v \geq 0, \quad \forall e = (u, v) \in E$ (相補性条件)</li>
</ul>

<p>このフロー整合性条件は, 主問題が infeasible であった時のことを考慮し, 残余グラフ $G_\vecf$ と余剰量 $e_\vecf(v)$ を用いて次のように書き直しておく.</p>

<ul>
  <li>$G_\vecf$ 上に $S_\vecf$ の頂点から $T_\vecf$ の頂点へのパス(増大路)が存在しない. (カット条件<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote">3</a></sup>)</li>
</ul>

<p>フロー整合性条件を満たすフローに対しては, 全頂点で $e_\vecf(v) = 0$ だからカット条件は成立する一方, フロー整合性条件を満たさないがカット条件を満たすフローが存在するならば, 主問題が infeasible であることが確かめられる.</p>

<p>また, 残余容量 $u_\vecf(e)$ と簡約コスト $c^\vecp(e)$, 逆辺を追加した辺集合 $\exE$ を用いると, 相補性条件は次の一つの式で表せる.</p>

<ul>
  <li>$u_\vecf(e) > 0 \Rightarrow c^\vecp(e) \geq 0, \quad \forall e = (u, v) \in \exE$ (相補性条件)</li>
</ul>

<p>Primal-Dual 法は, 容量制約と相補性条件を満たす主双対ペア $(\vec{f}, \vec{p})$ を持ち, カット条件が満たされるまで解を改善するアルゴリズムである.
具体的には, 初期解を得た後, 次の2つのステップを交互に繰り返すアルゴリズムである.</p>

<ul>
  <li>$\vec{f}$ は固定しておき, 相補性条件を保ちつつ $\vec{p}$ を変更することで, 双対目的関数値を改善する.</li>
  <li>$\vec{p}$ は固定しておき, 相補性条件を保ちつつ $\vec{f}$ を変更することで, フローをより整合させる. すなわち $G_\vecf$ 上での $S_\vecf$ 全体から $T_\vecf$ 全体へのカット容量を小さくする.</li>
</ul>

<h3>相補性条件の緩和</h3>

<p>Primal-Dual 法は相補性条件を常に保っていた. 容量スケーリング法では, 一部を $\Delta$-緩和した, 次の3つの条件を考える.</p>

<ul>
  <li>$l_e \leq f_e \leq u_e, \quad \forall e \in E$ (容量制約)</li>
  <li>$G^\Delta_\vecf$ 上に $S^\Delta_\vecf$ の頂点から $T^\Delta_\vecf$ の頂点へのパス($\Delta$-増大路)が存在しない ($\Delta$-緩和されたカット条件)</li>
  <li>$u_\vecf(e) \geq \Delta \Rightarrow c^\vecp(e) \geq 0, \quad \forall e = (u, v) \in \exE$ ($\Delta$-緩和された相補性条件)</li>
</ul>

<p>ここで, $G^\Delta_\vecf$ は $G_\vecf$ から容量が $\Delta$ 未満の辺を削除したものである.</p>

<p>容量が整数という条件の下, $\Delta = 1$ の時に元の問題と一致する. また, $\Delta$ が充分に大きいとき, 具体的には $\U := \max_e \{ u_e - l_e \}$ より大きいとき, 例えば $f_e = l_e, p_v = 0$ が上の条件を満たす.</p>

<p>容量スケーリング法は, 充分大きな $\Delta$ を取り, この $\Delta$-緩和された問題を解き, 得られた解を $\Delta/2$-緩和された問題の &quot;充分に良い&quot; 初期解に変形することを, $\Delta = 1$ になるまで繰り返すアルゴリズムである.
$\Delta$-緩和された問題の初期解が与えられた時, これを解くアルゴリズムは, Primal-Dual 法と同様, 次の2つのステップを交互に繰り返す. これを $\Delta$-scaling phase と呼ぶ.</p>

<ul>
  <li>$\vec{f}$ は固定しておき, 緩和された相補性条件を保ちつつ $\vec{p}$ を変更することで, 双対目的関数値を改善する.</li>
  <li>$\vec{p}$ は固定しておき, 緩和された相補性条件を保ちつつ $\vec{f}$ を変更することで, フローをより整合させる. すなわち $G^\Delta_\vecf$ 上での $S^\Delta_\vecf$ 全体から $T^\Delta_\vecf$ 全体へのカット容量を小さくする.</li>
</ul>

<h3>補足</h3>

<p>上では主問題側の制約を $\Delta$-緩和した. 一方で双対問題側の制約を $\varepsilon$-緩和すると, 例えば</p>

<ul>
  <li>$u_\vecf(e) > 0 \Rightarrow c^\vecp(e) \geq -\varepsilon, \quad \forall e = (u, v) \in \exE$ ($\varepsilon$-緩和された相補性条件)</li>
</ul>

<p>となる. これを用いると, コストスケーリング法 (Cost Scaling Algorithm) や平均長最小負閉路解消法 (Minimum Mean Cycle Cancel Algorithm) などが得られる.</p>

<h2>具体的なアルゴリズム</h2>

<p>引き続き, 以下の記号を使う.</p>

<ul>
  <li>$\exE$ は $E$ に逆辺を追加した集合</li>
  <li>$u_\vecf(e)$ は残余容量 (順辺に対しては $u_\vecf(e) := u_e - f_e$, 逆辺については $u_\vecf(\reve) := f_e - l_e$)</li>
  <li>$c^\vecp(e)$ は簡約コスト(順辺 $e = (u, v)$ に対しては $c^\vecp(e) := c_e + p_u - p_v$, 逆辺については $c^\vecp(\reve) := -c^\vecp(e)$)</li>
  <li>$G_\vecf$ は $\vecf$ に関する残余グラフ ($\exE$ のうち $u_\vecf(e) > 0$ なものを集めたもの. 容量は $u_\vecf(e)$.)</li>
  <li>$G^\Delta_\vecf$ は $G_\vecf$ のうち容量が $\Delta$ 以上のもののみからなるグラフ</li>
  <li>$\U := \max_e \{ u_e - l_e \}$</li>
  <li>$e_\vecf(v) := b_v - (\sum_{e \in \delta^+(v)} f_e - \sum_{e \in \delta^-(v)} f_e)$ (余剰量)</li>
  <li>$S_\vecf := \{ v | e_\vecf(v) > 0 \}$, $T_\vecf := \{ v | e_\vecf(v) < 0 \}$</li>
  <li>$S^\Delta_\vecf := \{ v | e_\vecf(v) \ge +\Delta \}$, $T^\Delta_\vecf := \{ v | e_\vecf(v) \le -\Delta \}$</li>
</ul>

<p>今回紹介する容量スケーリング法は, 次のようなアルゴリズムである.</p>

<p><strong>容量スケーリング法:</strong></p>

<ol>
  <li>$\Delta = 2^{\floor{\log_2 \U} + 1}$ とする.</li>
  <li>$\vec{p} = \veczero$, $\vec{f} = \vec{l}$ とする.</li>
  <li>$\Delta = 1$ なら終了し, そうでないならば $\Delta := \Delta / 2$ と更新する.</li>
  <li>$c^\vecp(e) < 0$ な $G^\Delta_\vecf$ の辺に対し, $u_\vecf(e) - \Delta$ より多く $u_\vecf(e)$ 以下だけ, つまり残余容量が $\Delta$ 未満になるように push する.</li>
  <li>&quot;$\Delta$-scaling phase&quot; を行う.</li>
  <li>3.に戻る.</li>
</ol>

<p>ここで, &quot;push する&quot; は, $f_e$ の値を増やすの意味. これに伴い, 順辺と逆辺残余容量 $u_\vecf$, この辺の端点の余剰量 $e_\vecf$ が変更されることに注意.
このアルゴリズムは, 次の不変条件を満たす.</p>

<ul>
  <li>2.の初期化が終わった時点以降, $\vecf$ は常に容量制約を満たす.</li>
  <li>3.に(2. もしくは 6. から)突入した時点で, $(\vecf, \vecp)$ は $\Delta$-緩和されたカット条件を満たす</li>
  <li>5.の(突入時, 脱出時を含めた)実行中, $(\vecf, \vecp)$ は $\Delta$-緩和された相補性条件を満たす.</li>
  <li>5.の実行中, $S^\Delta_\vecf$, $T^\Delta_\vecf$ に頂点が新たに加わることはない.</li>
</ul>

<p>例えば, 1. と 2. の初期化が終わった時点で, 任意の辺の残余容量は $\Delta$ 未満だから, この $(\vecf, \vecp)$ は $\Delta$-緩和されたカット条件と $\Delta$-緩和された相補性条件を満たす.
また, 4. の後 $c^\vecp(e) < 0 \Rightarrow u_\vecf(e) < \Delta$ が満たされるが, これは $\Delta$-緩和された相補性条件の対偶である.</p>

<p>$\Delta$-scaling phase は, 次の $\Delta$-scaling dual step と$\Delta$-scaling primal step を, $G^\Delta_\vecf$ に $S^\Delta_\vecf$ から $T^\Delta_\vecf$ へのパスが無くなるまで, すなわち $\Delta$-緩和されたカット条件を満たすまで, 交互に行う.</p>

<p><strong>$\Delta$-scaling dual step:</strong></p>

<ol>
  <li>$G^\Delta_\vecf$ 上で $S^\Delta_\vecf$ から全点へのコスト $c^\vecp(e)$ による (多始点)最短路長 $\vec{d}$ を求める.</li>
  <li>$\vecp := \vecp + \vec{d}$ と更新する.</li>
</ol>

<p>これにより, $G^\Delta_\vecf$ 上での $S^\Delta_\vecf$ からの最短経路に入りうる辺全体で $c^\vecp(e) = 0$ となる.
$S^\Delta_\vecf$ から $T^\Delta_\vecf$ へのパスが存在したから, その中で最短なものの辺が $c^\vecp(e) = 0$ を満たすようになった.
一方, この更新後も任意の $G^\Delta_\vecf$ の辺で $c^\vecp(e) \ge 0$ であるから, $(\vecf, \vecp)$ は $\Delta$-緩和された相補性条件を満たす.</p>

<p><strong>$\Delta$-scaling primal step:</strong></p>

<ol>
  <li>$S^\Delta_\vecf$ の頂点から $T^\Delta_\vecf$ の頂点へ $c^\vecp(e) = 0$ な $G^\Delta_\vecf$ の辺からなるパスを一つ取る.</li>
  <li>そのパスに沿ってフローを流す. 見つかったのが $s$-$t$ path $P$ であったとすると, $\Delta$ 以上 $\min\{ e_\vecf(s), -e_\vecf(t), \min_{e \in P} u_\vecf(e) \}$ 以下だけ流す.</li>
</ol>

<p>この更新は $c^\vecp(e) = 0$ な辺上で行われるから, $\Delta$-緩和された相補性条件を保存する.
また, この更新により $S^\Delta_\vecf$ と $T^\Delta_\vecf$ に頂点が新たに加わることはない.</p>

<h2>実装</h2>
<p><a href="library_design.html">ぼくの考えたさいきょうのフローライブラリ</a> から, 前処理, メインループ, primal step, dual step を変更する.</p>

<h3>新しい前処理</h3>

<p>前処理では, 容量制約を守る $\vecf$ を一つとり, $\Delta$ の初期値を決める.</p>

<div class="highlight"><pre class="highlight cpp"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Status</span><span class="p">,</span> <span class="n">Cost</span><span class="o">&gt;</span> <span class="n">solve</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">potential</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">Flow</span> <span class="n">rcap</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">rcap</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">rcap</span><span class="p">);</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rcap</span><span class="p">;</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rcap</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Flow</span> <span class="n">inf_flow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="n">inf_flow</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">inf_flow</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">());</span>
    <span class="n">Flow</span> <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;=</span> <span class="n">inf_flow</span><span class="p">)</span> <span class="n">delta</span> <span class="o">*=</span> <span class="n">SCALING_FACTOR</span><span class="p">;</span>
    <span class="c1">// 続く</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>
<h3>メインループと各フェーズの前処理</h3>

<p>メインループは次のようになる.</p>

<div class="highlight"><pre class="highlight cpp"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>    <span class="k">for</span> <span class="p">(</span><span class="n">delta</span> <span class="o">/=</span> <span class="n">SCALING_FACTOR</span><span class="p">;</span> <span class="n">delta</span><span class="p">;</span> <span class="n">delta</span> <span class="o">/=</span> <span class="n">SCALING_FACTOR</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">saturate_negative</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">dual</span><span class="p">(</span><span class="n">delta</span><span class="p">))</span> <span class="n">primal</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
    <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>
<p>ここで, <code>saturate_negative</code> は次のような関数である.</p>

<div class="highlight"><pre class="highlight cpp"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>  <span class="kt">void</span> <span class="nf">saturate_negative</span><span class="p">(</span><span class="k">const</span> <span class="n">Flow</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">excess_vs</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">deficit_vs</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">Flow</span> <span class="n">rcap</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">();</span>
      <span class="k">const</span> <span class="n">Cost</span> <span class="n">rcost</span> <span class="o">=</span> <span class="n">residual_cost</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">rcost</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rcap</span> <span class="o">&gt;=</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">rcap</span><span class="p">);</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rcap</span><span class="p">;</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rcap</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">V_id</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">excess_vs</span> <span class="o">:</span> <span class="n">deficit_vs</span><span class="p">).</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>
<h3>dual step</h3>
<p>ほぼ, Primal-Dual におけるフロー型の <code>0</code> との比較を $\Delta$ との比較に変えただけ.</p>

<div class="highlight"><pre class="highlight cpp"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre>  <span class="kt">bool</span> <span class="nf">dual</span><span class="p">(</span><span class="k">const</span> <span class="n">Flow</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dist</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">unreachable</span><span class="p">);</span>
    <span class="n">parent</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
    <span class="n">excess_vs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove_if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">excess_vs</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">excess_vs</span><span class="p">),</span>
                                   <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">;</span> <span class="p">}),</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">excess_vs</span><span class="p">));</span>
    <span class="n">deficit_vs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove_if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">deficit_vs</span><span class="p">),</span>
                                    <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">deficit_vs</span><span class="p">),</span>
                                    <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">delta</span><span class="p">;</span> <span class="p">}),</span>
                     <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">deficit_vs</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">v</span> <span class="o">:</span> <span class="n">excess_vs</span><span class="p">)</span> <span class="n">pq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="n">farthest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">deficit_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
      <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="n">farthest</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">delta</span><span class="p">)</span> <span class="o">++</span><span class="n">deficit_count</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">deficit_count</span> <span class="o">&gt;=</span> <span class="n">deficit_vs</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">new_dist</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">residual_cost</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">new_dist</span> <span class="o">&gt;=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_dist</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="k">decltype</span><span class="p">(</span><span class="n">pq</span><span class="p">)();</span> <span class="c1">// pq.clear() doesn't exist.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">V_id</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">potential</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">farthest</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">deficit_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>
<h3>primal step</h3>

<p>こちらも同様. $\Delta$ 以上しか流さないようにしていることに注意.</p>

<div class="highlight"><pre class="highlight cpp"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>  <span class="kt">void</span> <span class="nf">primal</span><span class="p">(</span><span class="k">const</span> <span class="n">Flow</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">t</span> <span class="o">:</span> <span class="n">deficit_vs</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">farthest</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="n">Flow</span> <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>
      <span class="n">V_id</span> <span class="n">v</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">f</span> <span class="o">&gt;=</span> <span class="n">delta</span><span class="p">;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">residual_cap</span><span class="p">());</span>
      <span class="p">}</span>
      <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">;)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">=</span> <span class="o">*</span><span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
        <span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
        <span class="k">const</span> <span class="kt">size_t</span> <span class="n">u</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">;</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">b</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f</span><span class="p">;</span>
      <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div>
<h2>計算量</h2>

<p>primal step は $O(m)$, dual step は $O(m \log m)$ である.</p>

<p>$\U$ を $\max_e \{ u_e - l_e \}$ とすると, $\Delta$ の初期値は $O(\U)$ であり, 合計 $O(\log \U)$ 回の scaling phase がある.</p>

<p>$\Delta$-scaling phase で流すフロー量を $F_\Delta$ とする.
フェーズ末尾を除く各 primal/dual step につき, 少なくとも $\Delta$ だけフローを流すから, 上の実装は $O ( \sum_\Delta (F_\Delta / \Delta) m \log m )$ になる.
この $F_\Delta$ について考える.</p>

<p>大雑把に言うと, 次の2つを示す:</p>

<ul>
  <li>フェーズの前処理で追加されるフローの不整合度は $O(m \Delta)$ である.</li>
  <li>前のフェーズから残っているフローの不整合度のうち, 解決出来るのは $O(m \Delta)$ である.</li>
</ul>

<p>さて, $\Delta$ を一つ固定し, $\Delta$-scaling phase の前処理を行う直前 ($2\Delta$-scaling phase の直後又は初回) のフローを $\vecf'$, 前処理の直後のフローを $\vecf$ とし, (前処理でポテンシャルは不変なので両方に)対応するポテンシャルを $\vecp$ とすると,</p>

<ul>
  <li>$G^{2\Delta}_{\vecf'}$ 上に $S^{2\Delta}_{\vecf'}$ の頂点から $T^{2\Delta}_{\vecf'}$ の頂点へのパス($2\Delta$-増大路)が存在しない ($2\Delta$-緩和されたカット条件)</li>
  <li>$c^\vecp(e) < 0 \Rightarrow u_{\vecf'}(e) < 2 \Delta, \quad \forall e = (u, v) \in \exE$ ($2 \Delta$-緩和された相補性条件の対偶)</li>
</ul>

<p>が成り立つ. 各 primal step では $S^\Delta_\vecf$ の頂点から $T^\Delta_\vecf$ の頂点にフローを流す. この始点/終点になりうる頂点を4つに分割し,</p>

<ul>
  <li>$A = S^{2\Delta}_{\vecf'} \cap S^\Delta_\vecf$,</li>
  <li>$B = T^{2\Delta}_{\vecf'} \cap T^\Delta_\vecf$,</li>
  <li>$C = S^\Delta_\vecf \setminus (A \cup B)$,</li>
  <li>$D = T^\Delta_\vecf \setminus (A \cup B)$</li>
</ul>

<p>とすると, $F_\Delta$ は $A \cup C$ から $B \cup D$ に流れることになる.</p>

<p>$\Delta$-scaling phase の前処理は $c^\vecp(e) < 0$ な辺の残余容量が無くなるように各辺 $e$ に push するから, $(\vecf', \vecp)$ に対する $2\Delta$-緩和された相補性条件から, 各辺 $e$ で $|f_e - f'_e| < 2 \Delta$ であり, $\sum_v |e_\vecf(v) - e_{\vecf'}(v)| < 4 m \Delta$ である.</p>

<p>また, $s \in C$ に対し, $e_\vecf(s) \ge \Delta > 0$ であるが, $s \not \in S^{2\Delta}_{\vecf'}$, すなわち $e_{\vecf'}(s) < 2 \Delta$ であったから,
$$|e_\vecf(s)| = e_\vecf(s) = e_\vecf(s) - e_{\vecf'}(s) + e_\vecf'(s) < |e_\vecf(s) - e_{\vecf'}(s)| + 2 \Delta$$
である. 同様に $t \in D$ に対しても $|e_\vecf(t)| < |e_\vecf(t) - e_{\vecf'}(t)| + 2 \Delta$ であるから,
$C$ と $D$ に対する $|e_\vecf(v)|$ の合計は高々 $\sum_v |e_\vecf(v) - e_{\vecf'}(v)| + 2 \Delta |C \cup D| < 4m\Delta + 2n\Delta = O(m \Delta)$ である.
従って, $A$ から $D$, $C$ から $B$, $C$ から $D$ に流すフロー量の合計は $O(m \Delta)$.</p>

<p>一方, $(\vecf', \vecp)$ に対する $2\Delta$-緩和されたカット条件から, $A$ から $B$ は $G^{2 \Delta}_{\vecf'}$ 上に パスが存在しない.
従って, $G_{\vecf'}$ 上での最小 $A$-$B$ カットの容量は高々 $2 m \Delta$ である.
$|f_e - f'_e| < 2 \Delta$ であったから, $G_{\vecf}$ での最小 $A$-$B$ カットの容量も $O(m \Delta)$ であり, $A$ から $B$ に流せるフロー量の合計は $O(m \Delta)$.</p>

<p>以上を纏めて, $F_\Delta = O(m \Delta)$, 従って全フェーズ合わせて $O ( \sum_\Delta (F_\Delta / \Delta) m \log m ) = O(\sum_\Delta m^2 \log m) = O(m^2 \log m \log \U)$ である.</p>

<p>scaling factor を $2$ ではなく $\alpha$ とすると, $O(m^2 \alpha \log m \log_\alpha \U)$ になる.</p>

<h3>別の方針</h3>

<p>実質的な内容は同じであるが, 人によっては次の方針が $A, B, C, D$ への分割を考えるより明瞭に思えるかもしれない.</p>

<ol>
  <li>$\vecf$ に対し, $V \cup \{s, t\}$ を頂点とするグラフ $H_\vecf$ で, $\overleftrightarrow{E}$ に残余容量で辺容量を入れた辺と, $s$ から $v$ に容量 $\max\{0, e_\vecf(v)\}$ の辺, $v$ から $t$ に容量 $\max\{0, -e_\vecf(v)\}$ の辺を持つものを考える.</li>
  <li>$G_\vecf$ 上の $S^\Delta_\vecf$ から $T^\Delta_\vecf$ への $\Delta$-残余パスは $H_\vecf$ 上の $s$ から $t$ への $\Delta$-残余パスと一対一対応し, $F_\Delta$ は $\Delta$-scaling phase 開始時のフロー $\vecf$ に対応する $H_\vecf$ の最大 $s$-$t$ フロー量で上から抑えられる.</li>
  <li>$\Delta$-scaling phase の前処理の直前のフロー $\vecf'$ に対応する $H_{\vecf'}$ の最小カットの容量は ($2\Delta$-カット条件から) $O(m \Delta)$.</li>
  <li>$H_{\vecf'}$ と $H_\vecf$ で, 各辺の容量の差の絶対値の和は $O(m \Delta)$. これは元のグラフの辺容量だけでなく $e_\vecf$ の変化も含むことに注意.</li>
  <li>従って, $H_\vecf$ の最小 $s$-$t$ カット容量も $O(m \Delta)$ で, これを言えばよかった.</li>
</ol>

<h3>注意</h3>
<p>Z. Király and P. Kovács (2012) の Capacity Scaling (CAS) は恐らく上記のアルゴリズムとほぼ同じであるが,
これはよく知られた Capacity Scaling Algorithm から前処理を少し削っている.
そして &quot;In this case, the polynomial running time bound is not proved&quot; とあるので, 上の僕の証明は間違っているかもしれない...
不備を見つけたら, 連絡をいただけるとありがたいです.</p>

<p>さて, 教科書的な容量スケーリング法では, 任意の頂点対 $(u, v)$ に対し, $u$ から $v$ への充分大きな容量のパスがあることを仮定する (これは, 適当な頂点を一つ選び, 任意の頂点との間にコスト $\infty$ の辺を双方向に追加すれば容易に満たせる).
また, $\Delta$ の倍数しか流さないようにすることが多いようだ.
充分容量の大きいパスがある仮定の下, 各 $\Delta$-scaling phase は $S^\Delta_\vecf$ か $T^\Delta_\vecf$ が空になることにより終了する事が示せる.
これを用いると, 上でいう $A$ から $B$ に流れるフローを考える必要がなくなり, 証明がより簡単になる.
上の証明が正しく無さそうだと思う人は, この前処理を入れるとよいだろう.</p>

<h2>参考文献</h2>

<ol>
  <li><a href="https://doi.org/10.1145/62212.62249">J.B.Orlin, &quot;A faster strongly polynomial minimum cost flow algorithm&quot;, Oper. Res. 41 (1993) 338-350.</a></li>
  <li><a href="https://www.amazon.co.jp/dp/013617549X" title="Network Flows: Theory, Algorithms, and Applications">R.K.Ahuja, T.L.Magnanti, J.B.Orlin, &quot;Network Flows: Theory, Algorithms, and Applications&quot;, Prentice-Hall, Inc., 1993.</a></li>
  <li><a href="https://arxiv.org/abs/1207.6381">Z. Király, P. Kovács, &quot;Efficient implementations of minimum-cost flow algorithms&quot;, Acta Universitatis Sapientiae, Informatica, 4, 1 (2012) 67-118.</a></li>
</ol>

<ul>
  <li>1.はちゃんと読んでいないが, 容量 $\infty$ なものについて扱い, その後輸送問題への変形を使って有限容量に対応しているようだ.</li>
  <li>2.では 10.2 節で扱われている. ちゃんと書いていないが, $\Delta$-scaling phase の終了条件の正当性に Assumption 9.4 (上の注意で言った仮定)が効いている.</li>
  <li>3.で上記の注意が出てくる. &quot;証明されていないが, この実装の方が有意に速かったのでこっちを使った&quot; という旨が書かれている.</li>
</ul>

<h2>謝辞</h2>

<p><a href="https://twitter.com/tokoharu_sakura">とこはるさん</a> には事前に読んでいただき, 有用なコメントと共に安心感をいただきました. ありがとうございました!</p>

<h2>ソースコード</h2>

<details>
  <summary>
長いので折りたたみ  </summary>
<div class="highlight"><pre class="highlight cpp"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cstdint&gt;
#include &lt;numeric&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
</span>
<span class="k">enum</span> <span class="n">Objective</span> <span class="p">{</span>
    <span class="n">MINIMIZE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">MAXIMIZE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">Status</span> <span class="p">{</span>
    <span class="n">OPTIMAL</span><span class="p">,</span>
    <span class="n">INFEASIBLE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Flow</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Cost</span><span class="p">,</span> <span class="n">Objective</span> <span class="n">objective</span> <span class="o">=</span> <span class="n">Objective</span><span class="o">::</span><span class="n">MINIMIZE</span><span class="p">,</span> <span class="n">Flow</span> <span class="n">SCALING_FACTOR</span> <span class="o">=</span> <span class="mi">2</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">MinCostFlow</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">V_id</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">E_id</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">Edge</span> <span class="p">{</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">MinCostFlow</span><span class="p">;</span>

    <span class="n">V_id</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">;</span>
    <span class="n">Flow</span> <span class="n">flow</span><span class="p">,</span> <span class="n">cap</span><span class="p">;</span>
    <span class="n">Cost</span> <span class="n">cost</span><span class="p">;</span>
    <span class="n">E_id</span> <span class="n">rev</span><span class="p">;</span>

  <span class="nl">public:</span>
    <span class="n">Edge</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">Edge</span><span class="p">(</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">V_id</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">Flow</span> <span class="n">cap</span><span class="p">,</span> <span class="k">const</span> <span class="n">Cost</span> <span class="n">cost</span><span class="p">,</span>
         <span class="k">const</span> <span class="n">E_id</span> <span class="n">rev</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">src</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">dst</span><span class="p">(</span><span class="n">dst</span><span class="p">),</span> <span class="n">flow</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">cap</span><span class="p">(</span><span class="n">cap</span><span class="p">),</span> <span class="n">cost</span><span class="p">(</span><span class="n">cost</span><span class="p">),</span> <span class="n">rev</span><span class="p">(</span><span class="n">rev</span><span class="p">)</span> <span class="p">{}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">Flow</span> <span class="n">residual_cap</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">cap</span> <span class="o">-</span> <span class="n">flow</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">};</span>

<span class="nl">public:</span>

  <span class="k">class</span> <span class="nc">EdgePtr</span> <span class="p">{</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">MinCostFlow</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">MinCostFlow</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">E_id</span> <span class="n">e</span><span class="p">;</span>

    <span class="n">EdgePtr</span><span class="p">(</span><span class="k">const</span> <span class="n">MinCostFlow</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">E_id</span> <span class="n">e</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">instance</span><span class="p">(</span><span class="n">instance</span><span class="p">),</span> <span class="n">v</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">e</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">{}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">edge</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">e</span><span class="p">];</span> <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">rev</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">=</span> <span class="n">edge</span><span class="p">();</span>
      <span class="k">return</span> <span class="n">instance</span><span class="o">-&gt;</span><span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">][</span><span class="n">e</span><span class="p">.</span><span class="n">rev</span><span class="p">];</span>
    <span class="p">}</span>

  <span class="nl">public:</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">V_id</span> <span class="n">src</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">rev</span><span class="p">().</span><span class="n">dst</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">V_id</span> <span class="n">dst</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">edge</span><span class="p">().</span><span class="n">dst</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">Flow</span> <span class="n">flow</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">edge</span><span class="p">().</span><span class="n">flow</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">Flow</span> <span class="n">lower</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">rev</span><span class="p">().</span><span class="n">cap</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">Flow</span> <span class="n">upper</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">edge</span><span class="p">().</span><span class="n">cap</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">Cost</span> <span class="n">cost</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">edge</span><span class="p">().</span><span class="n">cost</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="n">Cost</span> <span class="n">gain</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">-</span><span class="n">edge</span><span class="p">().</span><span class="n">cost</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">};</span>

<span class="nl">private:</span>
  <span class="n">V_id</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&gt;</span> <span class="n">g</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Flow</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="n">MinCostFlow</span><span class="p">()</span> <span class="o">:</span> <span class="n">n</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">V_id</span> <span class="n">add_vertex</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">n</span><span class="p">;</span>
    <span class="n">g</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">b</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">V_id</span><span class="o">&gt;</span> <span class="n">add_vertices</span><span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">V_id</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">V_id</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">ret</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">g</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">b</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">EdgePtr</span> <span class="n">add_edge</span><span class="p">(</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">V_id</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">Flow</span> <span class="n">lower</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">Flow</span> <span class="n">upper</span><span class="p">,</span> <span class="k">const</span> <span class="n">Cost</span> <span class="n">cost</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">E_id</span> <span class="n">e</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">src</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="n">re</span> <span class="o">=</span> <span class="n">src</span> <span class="o">==</span> <span class="n">dst</span> <span class="o">?</span> <span class="n">e</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">dst</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lower</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="p">);</span>
    <span class="n">g</span><span class="p">[</span><span class="n">src</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Edge</span><span class="p">{</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">cost</span> <span class="o">*</span> <span class="n">objective</span><span class="p">,</span> <span class="n">re</span><span class="p">});</span>
    <span class="n">g</span><span class="p">[</span><span class="n">dst</span><span class="p">].</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">Edge</span><span class="p">{</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="o">-</span><span class="n">lower</span><span class="p">,</span> <span class="o">-</span><span class="n">cost</span> <span class="o">*</span> <span class="n">objective</span><span class="p">,</span> <span class="n">e</span><span class="p">});</span>
    <span class="k">return</span> <span class="n">EdgePtr</span><span class="p">{</span><span class="k">this</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">e</span><span class="p">};</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">add_supply</span><span class="p">(</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">Flow</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">amount</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">add_demand</span><span class="p">(</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">Flow</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span> <span class="p">}</span>

<span class="nl">private:</span>
  <span class="c1">// Variables used in calculation</span>
  <span class="k">static</span> <span class="n">Cost</span> <span class="k">constexpr</span> <span class="n">unreachable</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">Cost</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
  <span class="n">Cost</span> <span class="n">farthest</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Cost</span><span class="o">&gt;</span> <span class="n">potential</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Cost</span><span class="o">&gt;</span> <span class="n">dist</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span> <span class="o">*&gt;</span> <span class="n">parent</span><span class="p">;</span> <span class="c1">// out-forrest.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Cost</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Cost</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span>
                      <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;&gt;&gt;</span>
      <span class="n">pq</span><span class="p">;</span> <span class="c1">// should be empty outside of dual()</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">V_id</span><span class="o">&gt;</span> <span class="n">excess_vs</span><span class="p">,</span> <span class="n">deficit_vs</span><span class="p">;</span>

  <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">rev</span><span class="p">(</span><span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">][</span><span class="n">e</span><span class="p">.</span><span class="n">rev</span><span class="p">];</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">Edge</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">,</span> <span class="k">const</span> <span class="n">Flow</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">e</span><span class="p">.</span><span class="n">flow</span> <span class="o">+=</span> <span class="n">amount</span><span class="p">;</span>
    <span class="n">g</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">][</span><span class="n">e</span><span class="p">.</span><span class="n">rev</span><span class="p">].</span><span class="n">flow</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Cost</span> <span class="n">residual_cost</span><span class="p">(</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">V_id</span> <span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="n">Edge</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">e</span><span class="p">.</span><span class="n">cost</span> <span class="o">+</span> <span class="n">potential</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">-</span> <span class="n">potential</span><span class="p">[</span><span class="n">dst</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">dual</span><span class="p">(</span><span class="k">const</span> <span class="n">Flow</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dist</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">unreachable</span><span class="p">);</span>
    <span class="n">parent</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
    <span class="n">excess_vs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove_if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">excess_vs</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">excess_vs</span><span class="p">),</span>
                                   <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">;</span> <span class="p">}),</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">excess_vs</span><span class="p">));</span>
    <span class="n">deficit_vs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove_if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">deficit_vs</span><span class="p">),</span>
                                    <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">deficit_vs</span><span class="p">),</span>
                                    <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span> <span class="n">V_id</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">delta</span><span class="p">;</span> <span class="p">}),</span>
                     <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">deficit_vs</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">v</span> <span class="o">:</span> <span class="n">excess_vs</span><span class="p">)</span> <span class="n">pq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="n">farthest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">deficit_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">const</span> <span class="k">auto</span> <span class="p">[</span><span class="n">d</span><span class="p">,</span> <span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
      <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="n">farthest</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">delta</span><span class="p">)</span> <span class="o">++</span><span class="n">deficit_count</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">deficit_count</span> <span class="o">&gt;=</span> <span class="n">deficit_vs</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">new_dist</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">residual_cost</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">new_dist</span> <span class="o">&gt;=</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_dist</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="k">decltype</span><span class="p">(</span><span class="n">pq</span><span class="p">)();</span> <span class="c1">// pq.clear() doesn't exist.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">V_id</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">potential</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">farthest</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">deficit_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">primal</span><span class="p">(</span><span class="k">const</span> <span class="n">Flow</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">t</span> <span class="o">:</span> <span class="n">deficit_vs</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">farthest</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="n">Flow</span> <span class="n">f</span> <span class="o">=</span> <span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>
      <span class="n">V_id</span> <span class="n">v</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">f</span> <span class="o">&gt;=</span> <span class="n">delta</span><span class="p">;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">residual_cap</span><span class="p">());</span>
      <span class="p">}</span>
      <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="n">delta</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">;)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">=</span> <span class="o">*</span><span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
        <span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
        <span class="k">const</span> <span class="kt">size_t</span> <span class="n">u</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">src</span><span class="p">;</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">b</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="n">f</span><span class="p">;</span>
      <span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="n">f</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">saturate_negative</span><span class="p">(</span><span class="k">const</span> <span class="n">Flow</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">excess_vs</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">deficit_vs</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">Flow</span> <span class="n">rcap</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">();</span>
      <span class="k">const</span> <span class="n">Cost</span> <span class="n">rcost</span> <span class="o">=</span> <span class="n">residual_cost</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">rcost</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rcap</span> <span class="o">&gt;=</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">rcap</span><span class="p">);</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rcap</span><span class="p">;</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rcap</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">V_id</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">excess_vs</span> <span class="o">:</span> <span class="n">deficit_vs</span><span class="p">).</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="nl">public:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Status</span><span class="p">,</span> <span class="n">Cost</span><span class="o">&gt;</span> <span class="n">solve</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">potential</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">Flow</span> <span class="n">rcap</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">rcap</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">rcap</span><span class="p">);</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">]</span> <span class="o">-=</span> <span class="n">rcap</span><span class="p">;</span>
        <span class="n">b</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rcap</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Flow</span> <span class="n">inf_flow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="n">inf_flow</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">inf_flow</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">());</span>
    <span class="n">Flow</span> <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">delta</span> <span class="o">&lt;=</span> <span class="n">inf_flow</span><span class="p">)</span> <span class="n">delta</span> <span class="o">*=</span> <span class="n">SCALING_FACTOR</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">delta</span> <span class="o">/=</span> <span class="n">SCALING_FACTOR</span><span class="p">;</span> <span class="n">delta</span><span class="p">;</span> <span class="n">delta</span> <span class="o">/=</span> <span class="n">SCALING_FACTOR</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">saturate_negative</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">dual</span><span class="p">(</span><span class="n">delta</span><span class="p">))</span> <span class="n">primal</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Cost</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">value</span> <span class="o">+=</span> <span class="n">e</span><span class="p">.</span><span class="n">flow</span> <span class="o">*</span> <span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">value</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">excess_vs</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">deficit_vs</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span> <span class="n">Status</span><span class="o">::</span><span class="n">OPTIMAL</span><span class="p">,</span> <span class="n">value</span> <span class="o">/</span> <span class="n">objective</span> <span class="p">};</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span> <span class="n">Status</span><span class="o">::</span><span class="n">INFEASIBLE</span><span class="p">,</span> <span class="n">value</span> <span class="o">/</span> <span class="n">objective</span> <span class="p">};</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Flow</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Cost</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">MaxGainFlow</span> <span class="o">=</span> <span class="n">MinCostFlow</span><span class="o">&lt;</span><span class="n">Flow</span><span class="p">,</span> <span class="n">Cost</span><span class="p">,</span> <span class="n">Objective</span><span class="o">::</span><span class="n">MAXIMIZE</span><span class="o">&gt;</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></details>

<h2>使用例</h2>

<h3>Library-Checker: Minimum cost b-flow</h3>
<p>問題は<a href="https://judge.yosupo.jp/problem/min_cost_b_flow">こちら</a></p>

<details>
  <summary>
長いので折りたたみ  </summary>
<div class="highlight"><pre class="highlight cpp"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
</pre></td><td class="rouge-code"><pre><span class="k">namespace</span> <span class="n">methods_to_add</span> <span class="p">{</span>
  <span class="c1">// 以下の3つの関数を MinCostFlow クラスに追加する</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">T</span> <span class="n">get_result_value</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">value</span> <span class="o">+=</span> <span class="p">(</span><span class="n">T</span><span class="p">)(</span><span class="n">e</span><span class="p">.</span><span class="n">flow</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">T</span><span class="p">)(</span><span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">value</span> <span class="o">/=</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">value</span> <span class="o">/</span> <span class="n">objective</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Cost</span><span class="o">&gt;</span> <span class="n">get_potential</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Not strictly necessary, but re-calculate potential to bound the potential values,</span>
    <span class="c1">// plus make them somewhat canonical so that it is robust for the algorithm chaneges.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">potential</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">potential</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">es</span> <span class="o">:</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">es</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">residual_cap</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">potential</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">potential</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">],</span> <span class="n">potential</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">.</span><span class="n">cost</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">potential</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">get_cut</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">excess_vs</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">deficit_vs</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">unreachable</span><span class="p">))</span>
        <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#include &lt;cstdint&gt;
#include &lt;cstdio&gt;
#include &lt;set&gt;
#include &lt;string&gt;
</span>
<span class="cp">#define REP(i, b, n) for (int i = (int)(b); i &lt; (int)(n); ++i)
#define rep(i, n) REP(i, 0, n)
#define loop(n) rep(i##__COUNTER__, n)
</span>
<span class="kt">int</span> <span class="nf">readI</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="nf">readLL</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">"%lld"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">i2s</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="s">"-"</span> <span class="o">+</span> <span class="n">i2s</span><span class="p">(</span><span class="o">-</span><span class="n">value</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="s">"0"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="sc">'0'</span> <span class="o">+</span> <span class="p">(</span><span class="n">value</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span>
    <span class="n">value</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">Flow</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">Cost</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">MCF</span> <span class="o">=</span> <span class="n">MinCostFlow</span><span class="o">&lt;</span><span class="n">Flow</span><span class="p">,</span> <span class="n">Cost</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">readI</span><span class="p">();</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">readI</span><span class="p">();</span>
  <span class="n">MCF</span> <span class="n">mcf</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">vs</span> <span class="o">=</span> <span class="n">mcf</span><span class="p">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Flow</span><span class="o">&gt;</span> <span class="n">original_bs</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="n">rep</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">Flow</span> <span class="n">b</span> <span class="o">=</span> <span class="n">readLL</span><span class="p">();</span>
    <span class="n">original_bs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">mcf</span><span class="p">.</span><span class="n">add_supply</span><span class="p">(</span><span class="n">vs</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">b</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MCF</span><span class="o">::</span><span class="n">EdgePtr</span><span class="o">&gt;</span> <span class="n">edges</span><span class="p">;</span>
  <span class="n">loop</span> <span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">readI</span><span class="p">();</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">readI</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Flow</span> <span class="n">lower</span> <span class="o">=</span> <span class="n">readLL</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Flow</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">readLL</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Cost</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">readLL</span><span class="p">();</span>
    <span class="n">edges</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">mcf</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">cost</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">status</span> <span class="o">=</span> <span class="n">mcf</span><span class="p">.</span><span class="n">solve</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">Status</span><span class="o">::</span><span class="n">INFEASIBLE</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">cut_vec</span> <span class="o">=</span> <span class="n">mcf</span><span class="p">.</span><span class="n">get_cut</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">cut_set</span><span class="p">(</span><span class="n">cut_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">cut_vec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">Flow</span> <span class="n">left_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cap_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">rep</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">(</span><span class="n">cut_set</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">?</span> <span class="n">left_sum</span> <span class="o">:</span> <span class="n">right_sum</span><span class="p">)</span> <span class="o">+=</span> <span class="n">original_bs</span><span class="p">[</span><span class="n">v</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="k">auto</span> <span class="n">sl</span> <span class="o">=</span> <span class="n">cut_set</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">src</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">const</span> <span class="k">auto</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">cut_set</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">dst</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">sl</span> <span class="o">!=</span> <span class="n">tr</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">sl</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cap_sum</span> <span class="o">+=</span> <span class="n">e</span><span class="p">.</span><span class="n">upper</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">cap_sum</span> <span class="o">-=</span> <span class="n">e</span><span class="p">.</span><span class="n">lower</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">left_sum</span> <span class="o">&gt;</span> <span class="n">cap_sum</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">right_sum</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">cap_sum</span><span class="p">));</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"infeasible"</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">potential</span> <span class="o">=</span> <span class="n">mcf</span><span class="p">.</span><span class="n">get_potential</span><span class="p">();</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">result_value</span> <span class="o">=</span> <span class="n">mcf</span><span class="p">.</span><span class="n">get_result_value</span><span class="o">&lt;</span><span class="n">__int128_t</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">puts</span><span class="p">(</span><span class="n">i2s</span><span class="p">(</span><span class="n">result_value</span><span class="p">).</span><span class="n">c_str</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">v</span> <span class="o">:</span> <span class="n">vs</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="n">i2s</span><span class="p">(</span><span class="n">potential</span><span class="p">[</span><span class="n">v</span><span class="p">]).</span><span class="n">c_str</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">e</span> <span class="o">:</span> <span class="n">edges</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="n">i2s</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">flow</span><span class="p">()).</span><span class="n">c_str</span><span class="p">());</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></details>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>厳密にはこの2つは異なる(例えば<a href="https://www.amazon.co.jp/dp/013617549X" title="Network Flows: Theory, Algorithms, and Applications">蜘蛛の巣本</a>)が, この記事では深く言及しない. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>ここでは最小費用 $\vecb$-フロー問題を採用する. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>一般的にどう呼ばれるか知らないが, ここではカット条件と呼ぶことにする. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>


          <footer>
            <h3>Tags</h3>
              <div class='tag'><a href="../../tags/フロー.html">フロー</a></div>
              <div class='tag'><a href="../../tags/最小費用流.html">最小費用流</a></div>
          </footer>
      </article>
    </main>
  </body>
</html>
